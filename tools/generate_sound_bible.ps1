[CmdletBinding()]
param()

$ErrorActionPreference = 'Stop'
Set-StrictMode -Version Latest

function Get-RepoRoot {
    $root = Resolve-Path -LiteralPath (Join-Path $PSScriptRoot '..')
    return $root.Path
}

function Replace-AutoGeneratedSection {
    param(
        [Parameter(Mandatory = $true)][string]$FilePath,
        [Parameter(Mandatory = $true)][string]$StartMarker,
        [Parameter(Mandatory = $true)][string]$EndMarker,
        [Parameter(Mandatory = $true)][string]$NewBody
    )

    $text = Get-Content -LiteralPath $FilePath -Raw -Encoding UTF8

    $startIndex = $text.IndexOf($StartMarker)
    if ($startIndex -lt 0) {
        throw "Start marker not found in ${FilePath}: $StartMarker"
    }

    $endIndex = $text.IndexOf($EndMarker)
    if ($endIndex -lt 0) {
        throw "End marker not found in ${FilePath}: $EndMarker"
    }

    if ($endIndex -lt $startIndex) {
        throw "End marker appears before start marker in $FilePath"
    }

    $before = $text.Substring(0, $startIndex + $StartMarker.Length)
    $after = $text.Substring($endIndex)

    $replacement = "`r`n`r`n$NewBody`r`n`r`n"

    $updated = $before + $replacement + $after
    Set-Content -LiteralPath $FilePath -Value $updated -Encoding UTF8
}

function Get-ModSoundsRegistrations {
    param(
        [Parameter(Mandatory = $true)][string]$JavaText
    )

    $map = @{}

    $patternSOUNDSRegister = '(?s)public\s+static\s+final\s+RegistryObject<SoundEvent>\s+([A-Za-z0-9_]+)\s*=\s*SOUNDS\.register\(\s*"([^"]+)"'
    foreach ($m in [regex]::Matches($JavaText, $patternSOUNDSRegister)) {
        $field = $m.Groups[1].Value
        $id = $m.Groups[2].Value
        $map[$id] = $field
    }

    $patternHelperRegister = '(?s)public\s+static\s+final\s+RegistryObject<SoundEvent>\s+([A-Za-z0-9_]+)\s*=\s*register\(\s*"([^"]+)"\s*\)\s*;'
    foreach ($m in [regex]::Matches($JavaText, $patternHelperRegister)) {
        $field = $m.Groups[1].Value
        $id = $m.Groups[2].Value
        $map[$id] = $field
    }

    return $map
}

function Get-SoundsJsonEntries {
    param(
        [Parameter(Mandatory = $true)][string]$JsonPath
    )

    $raw = Get-Content -LiteralPath $JsonPath -Raw -Encoding UTF8
    $obj = $raw | ConvertFrom-Json

    $entries = @{}
    foreach ($name in $obj.PSObject.Properties.Name) {
        $entries[$name] = $obj.$name
    }

    return $entries
}

function Get-OggStatusString {
    param(
        [string[]]$SoundNames = @(),
        [Parameter(Mandatory = $true)][string]$RepoRoot
    )

    if (-not $SoundNames -or $SoundNames.Count -eq 0) {
        return '(none)'
    }

    $parts = New-Object System.Collections.Generic.List[string]
    foreach ($n in $SoundNames) {
        $pathPart = $n
        if ($pathPart -match '^[^:]+:(.+)$') {
            $pathPart = $Matches[1]
        }

        $oggRel = "src/main/resources/assets/kruemblegard/sounds/$pathPart.ogg"
        $oggAbs = Join-Path $RepoRoot $oggRel
        $exists = Test-Path -LiteralPath $oggAbs
        $parts.Add("$oggRel = $exists")
    }

    return ($parts -join '; ')
}

function Get-ExistingDurations {
    param(
        [Parameter(Mandatory = $true)][string]$SoundBiblePath,
        [Parameter(Mandatory = $true)][string]$StartMarker,
        [Parameter(Mandatory = $true)][string]$EndMarker
    )

    $text = Get-Content -LiteralPath $SoundBiblePath -Raw -Encoding UTF8
    $startIndex = $text.IndexOf($StartMarker)
    $endIndex = $text.IndexOf($EndMarker)
    if ($startIndex -lt 0 -or $endIndex -lt 0 -or $endIndex -lt $startIndex) {
        return @{}
    }

    $section = $text.Substring($startIndex, ($endIndex - $startIndex))
    $chunks = $section -split "(?m)^####\s+"

    $durations = @{}
    foreach ($c in $chunks) {
        $chunk = $c.Trim()
        if ([string]::IsNullOrWhiteSpace($chunk)) { continue }

        $lines = $chunk -split "`r?`n"
        $key = $lines[0].Trim()
        if ([string]::IsNullOrWhiteSpace($key)) { continue }

        $sec = $null
        $ticks = $null

        if ($chunk -match '(?m)^- \*\*DurationSeconds\*\*: `([^`]+)`\s*$') {
            $sec = $Matches[1]
        }
        if ($chunk -match '(?m)^- \*\*DurationTicks\*\*: `([^`]+)`') {
            $ticks = $Matches[1]
        }

        if ($null -ne $sec -and $null -ne $ticks -and $sec -ne 'TBD' -and $ticks -ne 'TBD') {
            $durations[$key] = [pscustomobject]@{ Seconds = $sec; Ticks = $ticks }
        }
    }

    return $durations
}

$repoRoot = Get-RepoRoot

$modSoundsPath = Join-Path $repoRoot 'src\main\java\com\kruemblegard\registry\ModSounds.java'
$soundsJsonPath = Join-Path $repoRoot 'src\main\resources\assets\kruemblegard\sounds.json'
$soundBiblePath = Join-Path $repoRoot 'docs\Sound_Bible.md'

if (-not (Test-Path -LiteralPath $modSoundsPath)) { throw "Missing: $modSoundsPath" }
if (-not (Test-Path -LiteralPath $soundsJsonPath)) { throw "Missing: $soundsJsonPath" }
if (-not (Test-Path -LiteralPath $soundBiblePath)) { throw "Missing: $soundBiblePath" }

$javaText = Get-Content -LiteralPath $modSoundsPath -Raw -Encoding UTF8
$registrations = Get-ModSoundsRegistrations -JavaText $javaText
$soundsJson = Get-SoundsJsonEntries -JsonPath $soundsJsonPath

$existingDurations = Get-ExistingDurations -SoundBiblePath $soundBiblePath -StartMarker '<!-- AUTO-GENERATED:SOUNDS:START -->' -EndMarker '<!-- AUTO-GENERATED:SOUNDS:END -->'

$allKeys = New-Object System.Collections.Generic.HashSet[string]
foreach ($k in $registrations.Keys) { [void]$allKeys.Add($k) }
foreach ($k in $soundsJson.Keys) { [void]$allKeys.Add($k) }

$sortedKeys = $allKeys | Sort-Object

$lines = New-Object System.Collections.Generic.List[string]
$lines.Add('### Sounds (All Registered / Declared)')
$lines.Add('')

foreach ($k in $sortedKeys) {
    $soundEventId = "kruemblegard:$k"

    $field = '(not registered)'
    if ($registrations.ContainsKey($k)) {
        $field = $registrations[$k]
    }

    $subtitle = '(none)'
    $names = @()
    $streamed = $false

    if ($soundsJson.ContainsKey($k)) {
        $entry = $soundsJson[$k]

        $subtitleProp = $entry.PSObject.Properties['subtitle']
        if ($null -ne $subtitleProp -and $null -ne $subtitleProp.Value) {
            $subtitleValue = [string]$subtitleProp.Value
            if ($subtitleValue.Trim().Length -gt 0) {
                $subtitle = $subtitleValue
            }
        }

        $soundsProp = $entry.PSObject.Properties['sounds']
        if ($null -ne $soundsProp -and $null -ne $soundsProp.Value) {
            foreach ($s in $soundsProp.Value) {
                if ($s -is [string]) {
                    $names += $s
                    continue
                }

                $nameProp = $s.PSObject.Properties['name']
                if ($null -ne $nameProp -and $null -ne $nameProp.Value) {
                    $names += [string]$nameProp.Value
                }

                $streamProp = $s.PSObject.Properties['stream']
                if ($null -ne $streamProp -and $null -ne $streamProp.Value -and [bool]$streamProp.Value) {
                    $streamed = $true
                }
            }
        }
    }

    $namesDisplay = '(none)'
    if ($names.Count -gt 0) {
        $namesDisplay = ($names -join ', ')
    }

    $oggStatus = Get-OggStatusString -SoundNames $names -RepoRoot $repoRoot

    $streamedStr = if ($streamed) { 'true' } else { 'false' }

    $durationSeconds = 'TBD'
    $durationTicks = 'TBD'
    if ($existingDurations.ContainsKey($k)) {
        $durationSeconds = $existingDurations[$k].Seconds
        $durationTicks = $existingDurations[$k].Ticks
    }

    $subtitleDisplay = '(none)'
    if ($subtitle -ne '(none)') {
        $subtitleDisplay = ('`{0}`' -f $subtitle)
    }

    $lines.Add(('#### {0}' -f $k))
    $lines.Add(('- **SoundEvent ID**: `{0}`' -f $soundEventId))
    $lines.Add(('- **ModSounds field**: `{0}`' -f $field))
    $lines.Add(('- **Subtitle key**: {0}' -f $subtitleDisplay))
    $lines.Add(('- **sounds.json name(s)**: {0}' -f $namesDisplay))
    $lines.Add(('- **Streamed**: `{0}`' -f $streamedStr))
    $lines.Add(('- **OGG present**: {0}' -f $oggStatus))
    $lines.Add(('- **DurationSeconds**: `{0}`' -f $durationSeconds))
    $lines.Add(('- **DurationTicks**: `{0}` (round(seconds*20))' -f $durationTicks))
    $lines.Add('')
}

# Trim trailing blank lines for stable diffs
while ($lines.Count -gt 0 -and $lines[$lines.Count - 1] -eq '') {
    $lines.RemoveAt($lines.Count - 1)
}

$newBody = ($lines -join "`r`n")

Replace-AutoGeneratedSection -FilePath $soundBiblePath -StartMarker '<!-- AUTO-GENERATED:SOUNDS:START -->' -EndMarker '<!-- AUTO-GENERATED:SOUNDS:END -->' -NewBody $newBody

Write-Host "Updated Sound Bible: $soundBiblePath" -ForegroundColor Green
