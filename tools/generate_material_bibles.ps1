[CmdletBinding()]
param()

$ErrorActionPreference = 'Stop'
Set-StrictMode -Version Latest

function Get-RepoRoot {
    $root = Resolve-Path -LiteralPath (Join-Path $PSScriptRoot '..')
    return $root.Path
}

function Replace-AutoGeneratedSection {
    param(
        [Parameter(Mandatory = $true)][string]$FilePath,
        [Parameter(Mandatory = $true)][string]$StartMarker,
        [Parameter(Mandatory = $true)][string]$EndMarker,
        [Parameter(Mandatory = $true)][string]$NewBody
    )

    $text = Get-Content -LiteralPath $FilePath -Raw -Encoding UTF8

    $startIndex = $text.IndexOf($StartMarker)
    if ($startIndex -lt 0) {
        throw "Start marker not found in ${FilePath}: $StartMarker"
    }

    $endIndex = $text.IndexOf($EndMarker)
    if ($endIndex -lt 0) {
        throw "End marker not found in ${FilePath}: $EndMarker"
    }

    if ($endIndex -lt $startIndex) {
        throw "End marker appears before start marker in $FilePath"
    }

    $before = $text.Substring(0, $startIndex + $StartMarker.Length)
    $after = $text.Substring($endIndex)

    $replacement = "`r`n`r`n$NewBody`r`n`r`n"

    $updated = $before + $replacement + $after
    Set-Content -LiteralPath $FilePath -Value $updated -Encoding UTF8
}

function Get-RegisterCallSlice {
    param(
        [Parameter(Mandatory = $true)][string]$Text,
        [Parameter(Mandatory = $true)][int]$StartIndex
    )

    $openIndex = $Text.IndexOf('(', $StartIndex)
    if ($openIndex -lt 0) {
        throw 'Could not find opening parenthesis for register call.'
    }

    $depth = 0
    for ($i = $openIndex; $i -lt $Text.Length; $i++) {
        $ch = $Text[$i]
        if ($ch -eq '(') { $depth++ }
        elseif ($ch -eq ')') {
            $depth--
            if ($depth -eq 0) {
                # Expect a semicolon shortly after
                $semi = $Text.IndexOf(';', $i)
                if ($semi -lt 0) {
                    return $Text.Substring($StartIndex)
                }
                return $Text.Substring($StartIndex, ($semi - $StartIndex + 1))
            }
        }
    }

    return $Text.Substring($StartIndex)
}

function Parse-Blocks {
    param(
        [Parameter(Mandatory = $true)][string]$JavaText
    )

    $pattern = '(?s)BLOCKS\.register\(\s*"([^"]+)"\s*,\s*\(\)\s*->\s*new\s+([A-Za-z0-9_]+)'

    $blocks = New-Object System.Collections.Generic.List[object]

    foreach ($m in [regex]::Matches($JavaText, $pattern)) {
        $id = $m.Groups[1].Value
        $cls = $m.Groups[2].Value
        $slice = Get-RegisterCallSlice -Text $JavaText -StartIndex $m.Index

        $mapColor = $null
        if ($slice -match '\.mapColor\(\s*MapColor\.([A-Z0-9_]+)\s*\)') {
            $mapColor = "MapColor.$($Matches[1])"
        }

        $sound = $null
        if ($slice -match '\.sound\(\s*SoundType\.([A-Z0-9_]+)\s*\)') {
            $sound = "SoundType.$($Matches[1])"
        }

        $requiresTool = $false
        if ($slice -match '\.requiresCorrectToolForDrops\s*\(\s*\)') {
            $requiresTool = $true
        }

        $strength = $null
        if ($slice -match '\.strength\(\s*([^\)]+?)\s*\)') {
            $strength = $Matches[1].Trim()
        }

        $blocks.Add([pscustomobject]@{
            Id = $id
            Class = $cls
            MapColor = $mapColor
            Sound = $sound
            RequiresTool = $requiresTool
            Strength = $strength
        })
    }

    return $blocks
}

function Parse-Items {
    param(
        [Parameter(Mandatory = $true)][string]$JavaText
    )

    $items = @{}

    # Helper block item registrations
    $patternHelper = 'registerBlockItem\(\s*"([^"]+)"\s*,'
    foreach ($m in [regex]::Matches($JavaText, $patternHelper)) {
        $id = $m.Groups[1].Value
        $items[$id] = [pscustomobject]@{ Type = 'BlockItem'; Details = $null }
    }

    function Get-ItemDetailsFromSlice {
        param(
            [Parameter(Mandatory = $true)][string]$Slice
        )

        # Food (nutrition + saturation)
        if ($Slice -match '(?s)food\(\s*new\s+FoodProperties\.Builder\(\)\s*\.nutrition\((\d+)\)\s*\.saturationMod\(([-0-9\.]+)f?\)\s*\.build\(\)\s*\)') {
            return ('nutrition={0}, saturationMod={1}' -f $Matches[1], $Matches[2])
        }

        # Spawn eggs
        if ($Slice -match '(?s)new\s+ForgeSpawnEggItem\s*\(\s*(ModEntities\.[A-Za-z0-9_]+)\s*,\s*(0x[0-9a-fA-F]+)\s*,\s*(0x[0-9a-fA-F]+)') {
            return ('entity={0}, primaryColor={1}, secondaryColor={2}' -f $Matches[1], $Matches[2], $Matches[3])
        }

        # Tools
        if ($Slice -match '(?s)new\s+SwordItem\s*\(\s*(ModTiers\.[A-Za-z0-9_]+)\s*,\s*([-0-9\.]+)\s*,\s*([-0-9\.]+)F?\s*,') {
            return ('tier={0}, attackDamageBonus={1}, attackSpeed={2}' -f $Matches[1], $Matches[2], $Matches[3])
        }
        if ($Slice -match '(?s)new\s+PickaxeItem\s*\(\s*(ModTiers\.[A-Za-z0-9_]+)\s*,\s*([-0-9\.]+)\s*,\s*([-0-9\.]+)F?\s*,') {
            return ('tier={0}, attackDamageBonus={1}, attackSpeed={2}' -f $Matches[1], $Matches[2], $Matches[3])
        }
        if ($Slice -match '(?s)new\s+AxeItem\s*\(\s*(ModTiers\.[A-Za-z0-9_]+)\s*,\s*([-0-9\.]+)F?\s*,\s*([-0-9\.]+)F?\s*,') {
            return ('tier={0}, attackDamageBonus={1}, attackSpeed={2}' -f $Matches[1], $Matches[2], $Matches[3])
        }
        if ($Slice -match '(?s)new\s+ShovelItem\s*\(\s*(ModTiers\.[A-Za-z0-9_]+)\s*,\s*([-0-9\.]+)F?\s*,\s*([-0-9\.]+)F?\s*,') {
            return ('tier={0}, attackDamageBonus={1}, attackSpeed={2}' -f $Matches[1], $Matches[2], $Matches[3])
        }
        if ($Slice -match '(?s)new\s+HoeItem\s*\(\s*(ModTiers\.[A-Za-z0-9_]+)\s*,\s*([-0-9\.]+)\s*,\s*([-0-9\.]+)F?\s*,') {
            return ('tier={0}, attackDamageBonus={1}, attackSpeed={2}' -f $Matches[1], $Matches[2], $Matches[3])
        }

        return $null
    }

    # Direct ITEMS.register(...) with new <Type>
    $patternRegister = '(?s)ITEMS\.register\(\s*"([^"]+)"\s*,\s*\(\)\s*->\s*new\s+([A-Za-z0-9_]+)'
    foreach ($m in [regex]::Matches($JavaText, $patternRegister)) {
        $id = $m.Groups[1].Value
        $type = $m.Groups[2].Value
        $slice = Get-RegisterCallSlice -Text $JavaText -StartIndex $m.Index
        $details = Get-ItemDetailsFromSlice -Slice $slice
        $items[$id] = [pscustomobject]@{ Type = $type; Details = $details }
    }

    # Sort keys and return objects
    $result = New-Object System.Collections.Generic.List[object]
    foreach ($k in ($items.Keys | Sort-Object)) {
        $result.Add([pscustomobject]@{ Id = $k; Type = $items[$k].Type; Details = $items[$k].Details })
    }

    return $result
}

function Build-BlocksMarkdown {
    param(
        [Parameter(Mandatory = $true)][object[]]$Blocks
    )

    $lines = New-Object System.Collections.Generic.List[string]
    $lines.Add('### Blocks (All Registered)')
    $lines.Add('')

    foreach ($b in ($Blocks | Sort-Object Id)) {
        $lines.Add(('#### {0}' -f $b.Id))
        $lines.Add(('- **ID**: `kruemblegard:{0}`' -f $b.Id))
        $lines.Add(('- **Class**: `{0}`' -f $b.Class))

        if ($null -ne $b.MapColor) {
            $lines.Add(('- **Map color**: `{0}`' -f $b.MapColor))
        } else {
            $lines.Add('- **Map color**: TBD')
        }

        if ($null -ne $b.Sound) {
            $lines.Add(('- **Sound**: `{0}`' -f $b.Sound))
        } else {
            $lines.Add('- **Sound**: TBD')
        }

        $toolRule = if ($b.RequiresTool) { 'true' } else { 'false' }
        $lines.Add(('- **Tool rule**: requiresCorrectToolForDrops = `{0}`' -f $toolRule))

        if ($null -ne $b.Strength) {
            $lines.Add(('- **Strength tier**: `{0}`' -f $b.Strength))
        } else {
            $lines.Add('- **Strength tier**: TBD')
        }

        $lines.Add('')
    }

    while ($lines.Count -gt 0 -and $lines[$lines.Count - 1] -eq '') {
        $lines.RemoveAt($lines.Count - 1)
    }

    return ($lines -join "`r`n")
}

function Build-ItemsMarkdown {
    param(
        [Parameter(Mandatory = $true)][object[]]$Items
    )

    $lines = New-Object System.Collections.Generic.List[string]
    $lines.Add('### Items (All Registered)')
    $lines.Add('')

    foreach ($i in ($Items | Sort-Object Id)) {
        $lines.Add(('#### {0}' -f $i.Id))
        $lines.Add(('- **ID**: `kruemblegard:{0}`' -f $i.Id))
        $lines.Add(('- **Type**: `{0}`' -f $i.Type))
        if ($null -ne $i.Details -and ([string]$i.Details).Trim().Length -gt 0) {
            $lines.Add(('- **Details**: {0}' -f $i.Details))
        } else {
            $lines.Add('- **Details**: (none parsed)')
        }
        $lines.Add('')
    }

    while ($lines.Count -gt 0 -and $lines[$lines.Count - 1] -eq '') {
        $lines.RemoveAt($lines.Count - 1)
    }

    return ($lines -join "`r`n")
}

$repoRoot = Get-RepoRoot

$modBlocksPath = Join-Path $repoRoot 'src\main\java\com\kruemblegard\init\ModBlocks.java'
$modItemsPath  = Join-Path $repoRoot 'src\main\java\com\kruemblegard\registry\ModItems.java'

$blockBiblePath = Join-Path $repoRoot 'docs\Block_Material_Bible.md'
$itemBiblePath  = Join-Path $repoRoot 'docs\Item_Material_Bible.md'

if (-not (Test-Path -LiteralPath $modBlocksPath)) { throw "Missing: $modBlocksPath" }
if (-not (Test-Path -LiteralPath $modItemsPath)) { throw "Missing: $modItemsPath" }
if (-not (Test-Path -LiteralPath $blockBiblePath)) { throw "Missing: $blockBiblePath" }
if (-not (Test-Path -LiteralPath $itemBiblePath)) { throw "Missing: $itemBiblePath" }

$blocksJava = Get-Content -LiteralPath $modBlocksPath -Raw -Encoding UTF8
$itemsJava  = Get-Content -LiteralPath $modItemsPath -Raw -Encoding UTF8

$blocks = Parse-Blocks -JavaText $blocksJava
$items  = Parse-Items  -JavaText $itemsJava

$blocksMd = Build-BlocksMarkdown -Blocks $blocks
$itemsMd  = Build-ItemsMarkdown  -Items $items

Replace-AutoGeneratedSection -FilePath $blockBiblePath -StartMarker '<!-- AUTO-GENERATED:BLOCKS:START -->' -EndMarker '<!-- AUTO-GENERATED:BLOCKS:END -->' -NewBody $blocksMd

Replace-AutoGeneratedSection -FilePath $itemBiblePath -StartMarker '<!-- AUTO-GENERATED:ITEMS:START -->' -EndMarker '<!-- AUTO-GENERATED:ITEMS:END -->' -NewBody $itemsMd

Write-Host "Updated Block Material Bible: $blockBiblePath" -ForegroundColor Green
Write-Host "Updated Item Material Bible:  $itemBiblePath" -ForegroundColor Green
